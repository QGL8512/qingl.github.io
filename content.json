[{"title":"为什么Object.prototype.toString.call()可以检测数据类型","date":"2021-07-05T02:51:26.000Z","path":"2021/07/05/为什么Object-prototype-toString-call-可以检测数据类型/","text":"为什么Object.prototype.toString.call()可以检测数据类型？​ 每一个继承Object的对象都有一个toString()方法，如果toString()方法没有被重写的话，会返回[object type],其中type为对象的类型。但除了Object对象外，其他类型直接使用toString()方法会直接返回内容的字符串形式，所以使用call或者apply() 改变toString方法的执行上下文 12345678910111213141516171819202122232425262728 每一个对象都有一个toString()方法，默认情况下toString()被每一个Object对象继承，如果此方法未被重写，toString()返回&quot;[object type]&quot;,其中的type是对象的类型。let obj = new Object()obj.toString() // &quot;[object Object]&quot;MDN上是这么写的，toString()方法用久了转字符串，都没好好看过概念，习惯性以为只是返回一个字符串。比如：let num = 123let fun = function()&#123;&#125;let arr = [1, 2, 3]num.toString() // &quot;123&quot;fun.toString() // &quot;function()&#123;&#125;&quot;arr.toString() // &quot;1,2,3&quot; 这里并没有得到对象类型，是因为toString()方法为Object的原型方法， 而Array, Function, Number等作为Object的实例，都重写了toString方法，不同的类型的对象调用toString方法时，会根据原型链往上找，找到的都是重写后的toString()方法，如果我们删除重写后的toString()方法后，执行arr.toString()方法就能调用Object原型上的toString()方法delete Array.prototype.toStringarr.toString() // &quot;[object Array]&quot; 也就是说如果对象的toString()方法未被重写，就可以拿到数据类型， 但是大部分时候toString()方法都是被重写的，这时，就需要call()或者apply()来直接调用Object.prototype.toString","tags":[]},{"title":"My New Post","date":"2021-06-23T01:40:48.000Z","path":"2021/06/23/My-New-Post/","text":"typora-copy-images-to:images JS中的执行上下文，作用域链和闭包一, 执行上下文概念 当前代码的执行环境 执行上下文的三种类型： 全局执行上下文：全局执行环境是最外围的一个执行环境，在浏览器的全局对象是 window, this指向这个对象 函数执行上下文：可以有无数个，函数被调用的时候会被创建。每次调用函数都会创建一个新的执行上下文。 eval执行上下文，很少用。 每个执行上下文都有三个重要属性 1, 变量对象 2, 作用域链 3, this 执行上下文的生命周期：创建 ==&gt; 执行==&gt; 回收 创建阶段 创建变量对象 初始化函数的arguments 函数声明 变量声明 123456789101112131415161718function getName(name) &#123; var b = 2; function foo() &#123;&#125;; var bar = function() &#123;&#125;;&#125;getName(&#x27;qin&#x27;)变量对象 = &#123; arguments: &#123; 0: &#x27;qin&#x27;, length: 1 &#125;, name: &#x27;qin&#x27;, b: undefined, foo: reference to function foo()&#123;&#125;, bar: undefined&#125; 创建作用域链 作用域链是在变量对象之后创建，它本身包含变量对象。作用域链它主要用于变量解析。当要解析变量时，首先从变量所在的作用域进行查找，如果所在作用域没有，则沿着作用域链，查找父级作用域中是否存在该变量，如果没有紧接着向上进行查找直到找到全局作用域为止。 确定this的指向 this指向会包含很多种情况。在全局执行上下文中this总是指向全局对象，如浏览器环境下this指向window。而在函数执行上下文中this的指向取决于函数的调用方式，如果是被一个对象调用那么this指向这个对象，否则一般this是指向window或者在严格模式下，this指向undefined。 执行阶段执行变量赋值，代码执行 12345678910let a = &#x27;javascript&#x27;;function foo() &#123; console.log(&#x27;foo&#x27;); bar();&#125;function bar() &#123; console.log(&#x27;bar&#x27;);&#125;foo(); 上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入到当前执行栈。 当遇到 foo() 函数调用时， JavaScript 引擎创建了一个 foo 函数执行上下文并把它压入到当前执行栈的顶部。 当从 foo() 函数内部调用 bar() 函数时，JavaScript 引擎创建了一个 bar 函数执行上下文并把它压入到当前执行栈的顶部。 当函数 bar 执行完毕，它的执行上下文会从当前栈中弹出，控制流程到达下一个执行上下文，即 foo() 函数的执行上下文。 当 foo() 执行完成，它的执行上下文从栈弹出，控制流程到达全局执行上下文，一旦所有代码执行完成，javaScript 引擎就从当前栈中移除全局执行上下文。 回收阶段执行上下文出栈被垃圾回收机制进行回收 二，什么是作用域链1.什么是作用域？ 什么是词法作用域？ 作用域是查找变量（去哪找，怎么找）的一套规则。词法作用域在写代码的时候就确认了。js是基于词法作用域的语言，通过定义变量的位置就知道变量的作用域 2.什么是作用域链 ​ 当某个函数第一次被调用时，会创建一个执行环境及相应的作用域链，并把作用域链赋值给一个特殊的内部属性[[Scopes]]。然后，使用this, arguments 和其他命名参数的值来初始化函数的活动对象。但在作用域中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，…直至作用域链终点的全局执行环境 以上代码涉及三个上下文：全局上下文，foo()的局部上下文，bar()的局部上下文 简单来说，JS引擎进入代码后，会创建变量对象的一个的作用域链，以此保证对执行环境有权访问的所有变量和函数的有序访问。在进入函数后，会创建函数执行环境，并创建相应的变量对象，把我们的变量对象推入到作用域链的前端，作用域链的下一个结点保存的是外部环境的变量对象，作用域链的底端则是全局执行环境的变量对象 上面的例子可以叫做静态作用域链 为什么叫“静态”呢？ 因为这样的嵌套关系是分析代码就可以得出的，不需要运行，按照这种顺序访问变量的链就是静态作用域链，这种链的好处是可以直观的知道变量之间的引用关系。 相对的，还有动态作用域链，也就是作用域的引用关系与嵌套关系无关，与执行顺序有关，会在执行的时候动态创建不同函数、块的作用域的引用关系。缺点就是不直观，没法静态分析。 JavaScript 除了静态作用域链外，还有一个特点就是函数可以作为返回值。比如 12345678910111213function func () &#123; const obj =&#123; name: &#x27;qin&#x27;, age: 18 &#125; const a = 100; return function () &#123; console.log(a); &#125;&#125;const f2 = func();这就导致了一个问题，本来按照顺序创建调用一层层函数，按顺序创建和销毁作用域挺好的，但是如果内层函数返回了或者通过别的暴露出去了，那么外层函数销毁，内层函数却没有销毁，这时候怎么处理作用域，父作用域销不销毁？ （比如这里的 func 调用结束要不要销毁作用域） 三，闭包的设计概念：闭包就是指有权访问另一个函数作用域中的变量的函数 闭包是通过改变JS回收机制保留某段作用域的一种手段 考虑一下怎么解决这个静态作用域链中的父作用域先于子作用域销毁怎么解决。 12345678910111213141516171819202122var name = &#x27;qinguangli&#x27;function fun () &#123; const qin = &#x27;qin&#x27; function fun2 () &#123; const guang = &#x27;guang&#x27; function fun3 () &#123; const li = &#x27;li&#x27; console.log(qin, guang, li) &#125; return fun3 &#125; return fun2&#125;const fun4 = fun()const fun5 = fun4()console.dir(fun5)fun5()----------------------------------------------------------------父作用域有很多跟子涵数无关，肯定不能因为子函数没结束就一直常驻内存。这样肯定有性能问题，所以还是要销毁。 但是销毁了父作用域不能影响子函数，所以要再创建个对象，要把子函数内引用（refer）的父作用域的变量打包里来，给子函数打包带走。[[Scopes]] ，用这个来放函数打包带走的用到的环境。我们所考虑的这个解决方案：销毁父作用域后，把用到的变量包起来，打包给子函数，放到一个属性上。这就是闭包的机制。 四，闭包的使用场景123456789101112131415161718var fun = (function () &#123; var name = &#x27;qin&#x27; return &#123; getName: function () &#123; return name &#125;, changeName: function (newName) &#123; name = newName &#125; &#125;&#125;())fun.getName() // 得到qinfun.name // type errorfun.changeName(&#x27;qinguangli&#x27;)fun.getName()console.log(fun.getName()) // 通过闭包实现公共变量，私有变量----------------------------------------------------------------- 五，闭包的缺点123JavaScript 是静态作用域的设计，闭包是为了解决子函数晚于父函数销毁的问题，我们会在父函数销毁时，把子函数引用到的变量打成 Closure 包放到函数的 [[Scopes]] 上，让它计算父函数销毁了也随时随地能访问外部环境。父函数销毁，栈帧对应的内存马上释放，而返回的函数会把作用域链过滤出用到的引用形成闭包链放在堆中。 这就导致了一个隐患： 如果一个很大的对象被函数引用，本来函数调用结束就能销毁，但是现在引用却被通过闭包保存到了堆里，而且还一直用不到，那这块堆内存就一直没法使用，严重到一定程度就算是内存泄漏了。 作用域与执行上下文的关系javascript的执行分为：解释和执行两个阶段 解释阶段 词法分析 语法分析 作用域确定规则 执行阶段 创建执行上下文 执行代码函数 垃圾回收 作用域在函数定义时就已经确定了，而不是在函数调用时确定，但执行上下文是函数执行之前创建的。 延伸函数的生命周期123456789101112function fn () &#123; let a = 1 return function () &#123; console.log(++a) &#125;&#125;const result = fn()const result1 = fn()result()result() result1()result1() 在构造函数中作用域的使用123456789function Person () &#123; let num = 1 this.add = function () &#123; console.log(++num) &#125;&#125;const p = new Person()p.add()p.add() 在项目中的使用场景12345678910111213141516函数防抖/** fn [function] 需要防抖的函数* delay [number] 毫秒，防抖期限值*/function debounce(fn,delay)&#123; let timer = null //借助闭包 return function() &#123; if(timer)&#123; clearTimeout(timer) //进入该分支语句，说明当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时 timer = setTimeOut(fn,delay) &#125;else&#123; timer = setTimeOut(fn,delay) // 进入该分支说明当前并没有在计时，那么就开始一个计时 &#125; &#125;","tags":[]},{"title":"Hello World","date":"2021-06-23T01:35:17.278Z","path":"2021/06/23/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]